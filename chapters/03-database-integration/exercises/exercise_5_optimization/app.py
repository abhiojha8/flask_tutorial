"""
Exercise 5: Query Optimization & Audit Logging

OBJECTIVE:
Learn to write efficient database queries and implement audit trail for
tracking all data changes.

WHAT YOU'LL BUILD:
- Database indexes for faster queries
- Eager loading to prevent N+1 queries
- Audit logging system (who changed what, when)
- Soft delete functionality (mark as deleted instead of actually deleting)
- Query debugging to see actual SQL

LEARNING GOALS:
- Understand database indexes and when to use them
- Prevent N+1 query performance problems
- Implement audit trail for compliance
- Use soft deletes for data recovery
- Debug SQL queries generated by SQLAlchemy

WHY THIS MATTERS:

Performance Issue: N+1 Queries
‚ùå Without optimization:
   users = User.query.all()  # 1 query
   for user in users:
       print(user.posts)  # 100 more queries if 100 users!
   Total: 101 queries! üê¢

‚úÖ With optimization:
   users = User.query.options(joinedload(User.posts)).all()  # 1 query with JOIN
   for user in users:
       print(user.posts)  # No additional queries!
   Total: 1 query! üöÄ

Compliance: Audit Trail
- Who created this record?
- Who modified it?
- What changed?
- When did it change?
- Required for GDPR, SOC2, HIPAA compliance

DATABASE SCHEMA:

audit_logs table (NEW):
- id: Integer, Primary Key
- user_id: Integer, Foreign Key ‚Üí users.id (who made the change)
- action: String(50) (create/update/delete)
- table_name: String(50) (which table was affected)
- record_id: Integer (which record was affected)
- old_values: JSON (data before change)
- new_values: JSON (data after change)
- ip_address: String(45) (where the request came from)
- created_at: DateTime

Modified tables:
- All tables get: deleted_at (DateTime, nullable) for soft deletes

API ENDPOINTS:
- All existing endpoints from Exercise 3
- GET /audit-logs - View all audit logs
- GET /audit-logs?table_name=users - Filter by table
- GET /audit-logs?record_id=5 - Filter by record
- POST /users/<id>/restore - Restore soft-deleted user
- POST /posts/<id>/restore - Restore soft-deleted post

TODO CHECKLIST:
[ ] Add indexes to frequently queried columns
[ ] Fix N+1 queries with eager loading
[ ] Create AuditLog model
[ ] Implement audit logging helper function
[ ] Add audit logging to User CRUD operations
[ ] Add audit logging to Post CRUD operations
[ ] Add deleted_at column to User and Post
[ ] Modify GET endpoints to filter out soft-deleted records
[ ] Modify DELETE endpoints to soft delete
[ ] Implement restore endpoints
[ ] Add SQL query debugging
"""

from flask import Flask, request
from flask_restx import Api, Resource, fields, Namespace
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from datetime import datetime
import os
import json
from dotenv import load_dotenv
from sqlalchemy.orm import joinedload
from sqlalchemy import event, Index

load_dotenv()

def create_app():
    """
    Create and configure the Optimized Blog API with Audit Logging.

    This is production-ready code with performance optimization and compliance!
    """
    app = Flask(__name__)
    CORS(app)

    # ============================================================================
    # DATABASE CONFIGURATION
    # ============================================================================

    database_url = os.getenv('DATABASE_URL')
    if not database_url:
        raise ValueError("DATABASE_URL not found!")

    app.config['SQLALCHEMY_DATABASE_URI'] = database_url
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    # TODO: Enable SQL query logging for debugging
    # HINT: app.config['SQLALCHEMY_ECHO'] = True
    # This will print all SQL queries to the console!
    # Useful for finding N+1 problems and slow queries.

    api = Api(
        app,
        version='1.0',
        title='Optimized Blog API with Audit Logging',
        description='Exercise 5: Performance & Compliance',
        doc='/swagger'
    )

    # ============================================================================
    # DATABASE INITIALIZATION
    # ============================================================================

    db = SQLAlchemy(app)

    # ============================================================================
    # HELPER FUNCTIONS
    # ============================================================================

    def log_audit(user_id, action, table_name, record_id, old_values=None, new_values=None):
        """
        Helper function to create audit log entries.

        TODO: Implement this function to create AuditLog records.

        Args:
            user_id: ID of user making the change (can be None for system actions)
            action: 'create', 'update', or 'delete'
            table_name: Name of the table affected
            record_id: ID of the record affected
            old_values: Dictionary of old values (for update/delete)
            new_values: Dictionary of new values (for create/update)
        """
        # TODO: Get IP address from request
        # HINT: ip_address = request.remote_addr if request else None

        # TODO: Create AuditLog entry
        # HINT: audit = AuditLog(
        #           user_id=user_id,
        #           action=action,
        #           table_name=table_name,
        #           record_id=record_id,
        #           old_values=json.dumps(old_values) if old_values else None,
        #           new_values=json.dumps(new_values) if new_values else None,
        #           ip_address=ip_address,
        #           created_at=datetime.utcnow()
        #       )

        # TODO: Add and commit
        pass

    # ============================================================================
    # DATABASE MODELS
    # ============================================================================

    class Organization(db.Model):
        """Organization model with indexes."""
        __tablename__ = 'organizations'

        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(100), unique=True, nullable=False, index=True)  # Index for searches
        slug = db.Column(db.String(50), unique=True, nullable=False, index=True)  # Index for lookups
        plan = db.Column(db.String(20), default='free', index=True)  # Index for filtering
        is_active = db.Column(db.Boolean, default=True, index=True)  # Index for filtering
        created_at = db.Column(db.DateTime, default=datetime.utcnow)
        updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

        # TODO: Add deleted_at for soft deletes
        # HINT: deleted_at = db.Column(db.DateTime, nullable=True)

        # Relationships
        users = db.relationship('User', backref='organization', lazy=True)
        posts = db.relationship('Post', backref='organization', lazy=True)

        # TODO: Add composite index for common query patterns
        # HINT: __table_args__ = (
        #           Index('idx_org_active_plan', 'is_active', 'plan'),
        #       )


    class User(db.Model):
        """User model with indexes and soft delete."""
        __tablename__ = 'users'

        id = db.Column(db.Integer, primary_key=True)
        username = db.Column(db.String(80), unique=True, nullable=False, index=True)
        email = db.Column(db.String(120), unique=True, nullable=False, index=True)
        full_name = db.Column(db.String(100), nullable=True)
        is_active = db.Column(db.Boolean, default=True, index=True)
        organization_id = db.Column(db.Integer, db.ForeignKey('organizations.id'), nullable=False, index=True)
        created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
        updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

        # TODO: Add deleted_at for soft deletes
        # HINT: deleted_at = db.Column(db.DateTime, nullable=True, index=True)
        # Index on deleted_at allows fast filtering of active vs deleted records

        # Relationships
        posts = db.relationship('Post', backref='author', lazy=True, cascade='all, delete-orphan')

        # TODO: Add composite index for common queries
        # HINT: __table_args__ = (
        #           Index('idx_user_org_active', 'organization_id', 'is_active'),
        #       )

        def to_dict(self):
            """Convert to dictionary."""
            return {
                'id': self.id,
                'username': self.username,
                'email': self.email,
                'full_name': self.full_name,
                'is_active': self.is_active,
                'organization_id': self.organization_id,
                'created_at': self.created_at.isoformat() if self.created_at else None,
                'updated_at': self.updated_at.isoformat() if self.updated_at else None,
                'deleted_at': self.deleted_at.isoformat() if hasattr(self, 'deleted_at') and self.deleted_at else None
            }


    class Post(db.Model):
        """Post model with indexes and soft delete."""
        __tablename__ = 'posts'

        id = db.Column(db.Integer, primary_key=True)
        user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
        organization_id = db.Column(db.Integer, db.ForeignKey('organizations.id'), nullable=False, index=True)
        title = db.Column(db.String(200), nullable=False)
        content = db.Column(db.Text, nullable=True)
        status = db.Column(db.String(20), default='draft', index=True)  # Index for filtering
        view_count = db.Column(db.Integer, default=0)
        created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
        updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

        # TODO: Add deleted_at for soft deletes
        # HINT: deleted_at = db.Column(db.DateTime, nullable=True, index=True)

        # TODO: Add composite indexes for common query patterns
        # HINT: __table_args__ = (
        #           Index('idx_post_org_status', 'organization_id', 'status'),
        #           Index('idx_post_org_created', 'organization_id', 'created_at'),
        #       )
        #
        # WHY THESE INDEXES?
        # - idx_post_org_status: Fast queries like "get all published posts in org X"
        # - idx_post_org_created: Fast queries like "get recent posts in org X"

        def to_dict(self, include_author=False):
            """Convert to dictionary."""
            result = {
                'id': self.id,
                'user_id': self.user_id,
                'organization_id': self.organization_id,
                'title': self.title,
                'content': self.content,
                'status': self.status,
                'view_count': self.view_count,
                'created_at': self.created_at.isoformat() if self.created_at else None,
                'updated_at': self.updated_at.isoformat() if self.updated_at else None,
                'deleted_at': self.deleted_at.isoformat() if hasattr(self, 'deleted_at') and self.deleted_at else None
            }
            if include_author and self.author:
                result['author'] = self.author.to_dict()
            return result


    # TODO: Define AuditLog model

    class AuditLog(db.Model):
        """
        Audit log model for tracking all data changes.

        This is crucial for:
        - Compliance (GDPR, SOC2, HIPAA)
        - Debugging (who broke what?)
        - Security (detect unauthorized access)
        - Analytics (user behavior)
        """
        __tablename__ = 'audit_logs'

        # TODO: Define all columns
        # HINT: Use JSON type for old_values and new_values
        # HINT: from sqlalchemy.dialects.postgresql import JSON
        # HINT: old_values = db.Column(JSON, nullable=True)

        id = None  # TODO: db.Column(db.Integer, primary_key=True)
        user_id = None  # TODO: db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
        action = None  # TODO: db.Column(db.String(50), nullable=False, index=True)
        table_name = None  # TODO: db.Column(db.String(50), nullable=False, index=True)
        record_id = None  # TODO: db.Column(db.Integer, nullable=False, index=True)
        old_values = None  # TODO: db.Column(db.Text, nullable=True)  # JSON as text
        new_values = None  # TODO: db.Column(db.Text, nullable=True)  # JSON as text
        ip_address = None  # TODO: db.Column(db.String(45), nullable=True)
        created_at = None  # TODO: db.Column(db.DateTime, default=datetime.utcnow, index=True)

        # TODO: Add composite index for efficient querying
        # HINT: __table_args__ = (
        #           Index('idx_audit_table_record', 'table_name', 'record_id'),
        #       )

        def to_dict(self):
            """Convert to dictionary."""
            # TODO: Return dictionary with all fields
            # HINT: Parse old_values and new_values from JSON strings
            pass

    # ============================================================================
    # CREATE TABLES
    # ============================================================================

    with app.app_context():
        db.create_all()
        print("‚úÖ Database tables created with indexes!")

    # ============================================================================
    # API MODELS
    # ============================================================================

    users_ns = Namespace('users', description='User operations')
    posts_ns = Namespace('posts', description='Post operations')
    audit_ns = Namespace('audit-logs', description='Audit log operations')

    user_output_model = users_ns.model('User', {
        'id': fields.Integer(description='User ID'),
        'username': fields.String(description='Username'),
        'email': fields.String(description='Email'),
        'full_name': fields.String(description='Full name'),
        'is_active': fields.Boolean(description='Active status'),
        'organization_id': fields.Integer(description='Organization ID'),
        'created_at': fields.String(description='Created'),
        'updated_at': fields.String(description='Updated'),
        'deleted_at': fields.String(description='Deleted (soft delete)')
    })

    audit_output_model = audit_ns.model('AuditLog', {
        'id': fields.Integer(description='Audit log ID'),
        'user_id': fields.Integer(description='User who made the change'),
        'action': fields.String(description='Action (create/update/delete)'),
        'table_name': fields.String(description='Table affected'),
        'record_id': fields.Integer(description='Record ID'),
        'old_values': fields.Raw(description='Old values (JSON)'),
        'new_values': fields.Raw(description='New values (JSON)'),
        'ip_address': fields.String(description='IP address'),
        'created_at': fields.String(description='Timestamp')
    })

    # ============================================================================
    # AUDIT LOG ENDPOINTS
    # ============================================================================

    @audit_ns.route('/')
    class AuditLogList(Resource):
        """Audit log endpoints"""

        @audit_ns.doc('list_audit_logs')
        @audit_ns.marshal_list_with(audit_output_model)
        @audit_ns.param('table_name', 'Filter by table name')
        @audit_ns.param('record_id', 'Filter by record ID')
        @audit_ns.param('action', 'Filter by action (create/update/delete)')
        def get(self):
            """
            List audit logs with optional filters.

            TODO: Implement audit log querying with filters.

            QUERY PARAMETERS:
            - table_name: Filter logs for specific table
            - record_id: Filter logs for specific record
            - action: Filter by action type

            PERFORMANCE TIP:
            Use the composite index idx_audit_table_record for fast filtering!
            """
            # TODO: Build query with optional filters
            # HINT: query = AuditLog.query
            # HINT: if 'table_name' in request.args:
            #           query = query.filter_by(table_name=request.args['table_name'])
            # HINT: Order by created_at descending (most recent first)
            pass

    # ============================================================================
    # USER ENDPOINTS WITH AUDIT LOGGING
    # ============================================================================

    @users_ns.route('/')
    class UserList(Resource):
        """User endpoints with soft delete filtering"""

        @users_ns.doc('list_users')
        @users_ns.marshal_list_with(user_output_model)
        def get(self):
            """
            List all active (non-deleted) users.

            TODO: Filter out soft-deleted users.

            IMPORTANT: Only show users where deleted_at IS NULL
            """
            # TODO: Implement GET /users with soft delete filtering
            # HINT: User.query.filter(User.deleted_at.is_(None)).all()
            # Or: User.query.filter_by(deleted_at=None).all()
            pass

    @users_ns.route('/<int:id>')
    @users_ns.param('id', 'User identifier')
    class UserItem(Resource):
        """Single user endpoints with audit logging"""

        @users_ns.doc('delete_user')
        @users_ns.response(204, 'User soft-deleted')
        @users_ns.response(404, 'User not found')
        def delete(self, id):
            """
            Soft delete user (mark as deleted, don't actually delete).

            TODO: Implement soft delete.

            STEPS:
            1. Get user
            2. Set deleted_at = datetime.utcnow()
            3. Commit
            4. Log audit (action='delete', save old values)
            5. Return 204
            """
            # TODO: Implement soft DELETE /users/<id>
            # HINT: user.deleted_at = datetime.utcnow()
            # HINT: log_audit(None, 'delete', 'users', id, old_values=user.to_dict())
            pass

    @users_ns.route('/<int:id>/restore')
    @users_ns.param('id', 'User identifier')
    class UserRestore(Resource):
        """Restore soft-deleted user"""

        @users_ns.doc('restore_user')
        @users_ns.marshal_with(user_output_model)
        @users_ns.response(404, 'User not found')
        def post(self, id):
            """
            Restore a soft-deleted user.

            TODO: Implement restore functionality.

            STEPS:
            1. Get user (including deleted ones!)
            2. Check if deleted_at is not None
            3. Set deleted_at = None
            4. Commit
            5. Log audit (action='restore')
            6. Return user
            """
            # TODO: Implement POST /users/<id>/restore
            # HINT: user = User.query.get_or_404(id)  # Gets even deleted users
            # HINT: if not user.deleted_at: return error
            # HINT: user.deleted_at = None
            pass

    # ============================================================================
    # POST ENDPOINTS WITH EAGER LOADING
    # ============================================================================

    @posts_ns.route('/')
    class PostList(Resource):
        """Post endpoints with N+1 prevention"""

        @posts_ns.doc('list_posts')
        def get(self):
            """
            List all posts with author info (OPTIMIZED - no N+1 queries).

            TODO: Use eager loading to prevent N+1 queries.

            IMPORTANT: Enable SQLALCHEMY_ECHO to see the SQL!
            Without joinedload: You'll see 1 + N queries
            With joinedload: You'll see 1 query with JOIN
            """
            # TODO: Implement with eager loading
            # HINT: posts = Post.query.filter(Post.deleted_at.is_(None))\
            #                        .options(joinedload(Post.author))\
            #                        .all()
            # HINT: Return [post.to_dict(include_author=True) for post in posts]
            pass

    # ============================================================================
    # REGISTER NAMESPACES
    # ============================================================================

    api.add_namespace(users_ns, path='/users')
    api.add_namespace(posts_ns, path='/posts')
    api.add_namespace(audit_ns, path='/audit-logs')

    return app


if __name__ == '__main__':
    app = create_app()
    print("\n" + "="*70)
    print("OPTIMIZED BLOG API - Exercise 5: Performance & Compliance")
    print("="*70)
    print("üìö Learning Objectives:")
    print("  - Add database indexes for performance")
    print("  - Prevent N+1 queries with eager loading")
    print("  - Implement audit logging for compliance")
    print("  - Use soft deletes for data recovery")
    print("  - Debug SQL queries")
    print("\nüéØ Test Your Implementation:")
    print("  1. Enable SQLALCHEMY_ECHO and see the SQL")
    print("  2. Create a user and check audit_logs table")
    print("  3. Soft delete a user (DELETE /users/1)")
    print("  4. Verify user hidden (GET /users)")
    print("  5. Restore user (POST /users/1/restore)")
    print("  6. List posts and see only 1 SQL query (no N+1!)")
    print("  7. Filter audit logs (GET /audit-logs?table_name=users)")
    print("\nüåê Swagger UI: http://localhost:5000/swagger")
    print("üóÑÔ∏è  Check Supabase to see indexes and audit_logs table!")
    print("="*70 + "\n")

    app.run(debug=True, port=5000)
